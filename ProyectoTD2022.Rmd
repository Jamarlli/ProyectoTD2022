---
title: "ProyectoTD2022"
author: "Grupo K"
date: '2022-04-19'
output:
# Salida html 
  html_document:
    echo: yes
    number_sections: no
    theme: lumen
    toc: yes
# Salida pdf
  pdf_document:
    toc: yes      # Tabla de contenido (índice)
    toc_depth: 3  # Número de niveles de la tabla de contenido (índice) # 1, ##2,###3
    number_sections: no # Numeración de las secciones

---
## Introducción:
Este proyecto en R está enfocado a analizar los datos recogidos por sensores que 
monitorizan el nivel de ruido en diferentes localizaciones del barrio de Ruzafa.

### Instalación de paquetes necesarios:
```{r,echo=T, message = F, error = F, warning = F}

# Especificamos las librerías necesarias en esta lista

packages = c("tidyverse","knitr","ggplot2","readr","plotly","lubridate","gganimate","corrplot","GGally")

#use this function to check if each package is on the local machine
#if a package is installed, it will be loaded
#if any are not, the missing package(s) will be installed and loaded
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
  }
  library(x, character.only = TRUE)
})

#verify they are loaded
search()

```

### Numeración de los data frames correspondientes a las estaciones de medida:

1. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Sueca Esq. Denia
2. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Cádiz, 16
3. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Cádiz, 3
4. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Cuba, 3
5. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Sueca, 2
6. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Sueca, 61
7. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Sueca, 32
8. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Carles Cervera, Chaflán Reina Doña María
9. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Salvador Abril Chaflán Maestro José Serrano
10. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Vivons Chaflán Cádiz
11. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Carles Cervera, 34
12. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Puerto Rico, 21
13. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Doctor Serrano, 21
14. Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle General Prim Chaflán Donoso Cortés

```{r}
# Creamos un vector con los nombres de las estaciones para poder acceder a ellos si es necesario
nombre_estaciones <- 
  c("Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Sueca Esq. Denia",
  "Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Cádiz, 16",
  "Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Cádiz, 3",
  " Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Cuba, 3",
  "Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Sueca, 2",
  " Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Sueca, 61",
  " Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Sueca, 32",
  " Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Carles Cervera, Chaflán Reina Doña María",
  " Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Salvador Abril Chaflán Maestro José Serrano",
  " Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Vivons Chaflán Cádiz",
  " Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Carles Cervera, 34",
  " Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Puerto Rico, 21",
  " Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle Doctor Serrano, 21",
  " Datos diarios del sensor de ruido ubicado en el barrio de Ruzafa, en la calle General Prim Chaflán Donoso Cortés")

```

## Fase 4

### Importar los datos

```{r}
# Creamos un vector con los nombres de los ficheros (sin el ".csv")
nombres <- paste0('df',1:14)
nombres

# Con un bucle for y mediante la funcion assign() le asignamos a cada nombre del 
# vector su data frame correspondiente, leido del fichero con la función read_csv
for(x in nombres){
  assign(x,read_csv(str_c("data/",x,".csv"), 
                    col_types = cols(dateObserved = 
                                       col_datetime(format = "%Y-%m-%d"))))
}

# Si se quisiera comprobar el estado de los data frames tras la importación se 
# usaria la funcion head(), que muestra las primeras columnas de un dataframe 
# (dado que ocupa mucho espacio en el html/pdf y no aporta gran informacion al 
# corrector esta parte esta comentada)
vector_dfs <- list(df1,df2,df3,df4,df5,df6,df7,df8,df9,df10,df11,df12,df13,df14)
# for (x in 1:14){print(head(as.data.frame(vector_dfs[[x]]),n=1))}
```
### Fusionar todos los datos en un solo dataframe

```{r,echo=T, message = F, error = F, warning = F}
# Creamos un data frame("df") equivalente al df1 con una columna añadida que 
# dice de que estación proviene cada registro (en este caso todos provienen de la 1)
df <- df1 %>% mutate(df1,Estacion = 1)

# Con un bucle vamos haciendole joins a df añadiendo toda la informacion del 
# resto de data frames, incluyendo en todos la nueva columna que indica en que 
# estación se han recogido los datos
for(x in 2:14){
  df <- full_join(df,mutate(vector_dfs[[x]],Estacion = x))
}
```

### Exploración inicial de los datos

Utilizamos funciones como summary, head... Para asi tener una idea de como están
distribuidos nuestros datos y de esta forma trabajar de una manera más sencilla.

```{r}
# La función summary nos da una visualización de las columnas, sus clases y 
# otras informaciones
summary(df)

# La función glimpse de el paquete dplyr nos da una visualización rapida del 
# dataframe que estamos tratando.
glimpse(df)

# Por ultimo la función head nos muestra las primeras filas del df para hacernos
# una idea real
head(as.data.frame(df))

```

### Preguntas que se puedan responder con los datos disponibles

¿En qué franja horaria el nivel sonoro es más alto? ¿Y el más bajo?
¿En qué sensor el nivel sonoro es más alto? ¿Y el más bajo?
¿En qué día el nivel sonoro fue más alto? ¿Y el más bajo?
¿En qué mes el nivel sonoro es más alto? ¿Y el más bajo?

¿El nivel de ruido depende del día de la semana?
¿El nivel de ruido depende del mes?
¿El nivel de ruido depende de la estación del año?
¿El nivel de ruido depende de la parte del mes en la que estemos (principios, mediados, finales)?

¿Qué franjas horarias tienen los niveles de ruido más parecidos?
¿Qué días de la semana tienen los niveles de ruido más parecidos?
¿Qué meses tienen los niveles de ruido más parecidos?

¿Los niveles de ruido son más altos los fines de semana?
¿Se producen cambios en el nivel de ruido en épocas festivas?
¿En qué medida el nivel de ruido depende del sensor que lo mide?


## Fase 5: Acondicionar los datos para que se correspondan con un tidy dataset

### Eliminar datos innecesarios

```{r}
# Por las previsualizaciones anteriores podemos darnos cuenta de que hay dos 
# columnas que no varian, por lo tanto, podemos eliminarlas del df
all(df$entityType == "NoiseLevelObserved")
all(df$fiwareServicePath == "/sonometros")

df<- df[,-(3:4)]
```
### Renombrar las variables

```{r}
# Otra cosa de gran importancia es que los nombres de las columnas deben ser 
# representativos y se deben poder entender. Por ello le vamos a cambiar los 
# nombres a unos más simples

colnames(df)
colnames(df)<- c("id","Fecha_dato","id_sensor","1min","Dia 7-19h",
                 "Dia_tarde_noche", "Tarde 19-23h", "Noche 23-7h", 
                 "Dia_medidas", "Estacion")
```

### Representamos las variables en columnas y las observaciones en filas

```{r}
# De esta forma también nos podemos dar cuenta de que hay unas variables puestas 
# como columnas
df <-gather(df, key= Franja_horaria, value= Nivel_sonoro ,4:8)

# Finalmente visualizamos el data frame "df" tidy
head(as.data.frame(df))
```
### Ajustes extra de las variables

```{r}
min(df$Nivel_sonoro) 
max(df$Nivel_sonoro) # No puede haber registros con un Nivel sonoro infinito
which(df$Nivel_sonoro==Inf) # posicion de los registros con Nivel_sonoro = Inf

# Dado que hay dos registros con un Nivel Sonoro con valor de Infinito, 
# los reemplazamos por la media del resto de registros
df$Nivel_sonoro[which(df$Nivel_sonoro==Inf)]<-mean(df$Nivel_sonoro[-which(df$Nivel_sonoro==Inf)])

# Convertimos la estación a factor
df <- df %>% mutate(Estacion = as.factor(Estacion))

#Convertimos la Fecha_dato a fecha
df <- df %>% mutate(Fecha_dato = as.Date(Fecha_dato))

# Convertimos la Franja horaria a factor
df <- df %>% mutate(Franja_horaria = as.factor(Franja_horaria))
```

## Fase 6

### Graficos

#### Nivel sonoro por estación
```{r}
# Seleccionamos la media del nivel sonoro por estación y la estación
g_nsonoro <- df %>% group_by(Estacion) %>% 
  mutate(Media = mean(Nivel_sonoro)) %>% 
  select(Estacion, Media) %>% unique() %>% 
  
  # Hacemos un grafico de barras con ambas variables, de manera que el color 
  # dependa del nivel sonoro medio y añadimos limites al eje x para que se vea 
  # mejor la diferencia del nivel sonoro entre estaciones
  ggplot() + geom_col(aes(x= Estacion, y = Media, fill = Media)) + 
  coord_cartesian(ylim=c(50, 70)) + 
  
  # Añadimos las etiquetas y leyendas
  labs(x = "Estaciones", y = "Nivel sonoro medio",
       title ="Nivel sonoro por estación")

  #Aplicamos ggplotly para que el gráfico sea interactivo
  ggplotly(g_nsonoro,tooltip = c("x", "y")) 
```

```{r}
#Otra forma de ponerlo podría ser mediante boxplots

#Primero seleccionamos que dos variables queremos comparar
ggplot(df, aes(Estacion, Nivel_sonoro, colour = Estacion)) +
  geom_boxplot() +
  scale_y_log10() + 
  #Añadimos las etiquetas y leyendas
  labs(x = "Estaciones", y = "Nivel sonoro medio",
       title ="Nivel sonoro por estación")
  
```
#### Niveles sonoros máximos y minimos de cada estación
```{r}
# Seleccionamos los máximos y mínimos de cada estación y la estación
g_maxmin <- df %>% group_by(Estacion) %>% 
  mutate(minimo = min(Nivel_sonoro), maximo = max(Nivel_sonoro)) %>% 
  select(Estacion, maximo, minimo) %>%
  unique() %>%
  gather(key = Medida, value =Valor,-Estacion) %>% # Al crear las variables 
                                                   # minimo y maximo hay que 
                                                   # volver a hacer tidy el 
                                                   # data frame
  
  # Hacemos un grafico de barras con las variables Estacion, Valor y Medida y 
  # agrupando visualmente por estaciones con el argumento position
  ggplot() + 
  geom_col(aes(x = Estacion,y=Valor, fill=Medida), position = position_dodge(width = 0.65)) + 
  
  #Añadimos las etiquetas y leyendas
  labs(x = "Estaciones", y = "Nivel sonoro",
       title ="Niveles sonoros mínimos y máximos por estación")
  
  #Aplicamos ggplotly para que el gráfico sea interactivo
  ggplotly(g_maxmin)
```



#### Nivel sonoro por franja horaria
```{r}
#Se selecciona la media del nivel sonoro para cada franja horaria y la propia franja horaria, agrupando por esta última
g_nsonorofh <- df %>% group_by(Franja_horaria) %>% 
  mutate(Media = mean(Nivel_sonoro)) %>% 
  select(Franja_horaria, Media) %>% unique() %>% 
  #Se hace un gráfico de barras con ambas variables, de manera que el color dependa del nivel sonoro medio 
  ggplot() + geom_col(aes(x = Franja_horaria, y = Media, fill = Media)) + 
  scale_fill_gradient(name = "nivel", low = "mediumpurple4", high = "mediumorchid") +
  #Se añaden límites en el eje x para que se aprecie mejor la diferencia de nivel sonoro en cada franja horaria
  coord_cartesian(ylim=c(50, 65)) +
  #Se añaden las etiquetas y el título
  labs(x = "Franjas horarias", y = "Nivel sonoro medio",
       title ="Nivel sonoro por franja horaria") 

  #Se utiliza ggplotly para que el gráfico sea interactivo
  ggplotly(g_nsonorofh,tooltip = c("x", "y"))
```

#### Nivel sonoro por dia de la semana
```{r}
# Funcion para crear un id numerico del dia de la semana y poder hacer un grafico animado
id_ds <- function(x){
  match(x,c("lunes","martes","miércoles","jueves","viernes","sábado","domingo"))
}

# Adaptamos el df a nuestras necesidades
df %>% filter(str_detect(Franja_horaria, "h")) %>% 
  mutate(Dia_semana = fct_reorder(weekdays(Dia_medidas), wday(Dia_medidas, week_start = 1))) %>% 
  group_by(Dia_semana,Franja_horaria) %>% 
  mutate(Nivel_por_dia = mean(Nivel_sonoro), id_ds = id_ds(Dia_semana)) %>% 
  
#Se seleccionan solo las columnas necesarias
  select(Franja_horaria,Nivel_por_dia, Dia_semana,id_ds) %>% distinct() %>% 
  
  ggplot(aes(x=Dia_semana,y=Nivel_por_dia,col=Franja_horaria,group=Franja_horaria)) + 

  geom_line(size=1) +
  
  
  
#Se añaden las etiquetas y el título
  labs(x = "Días de la semana", y = "Nivel sonoro",
       title ="Nivel sonoro por franja horaria y día de la semana") + transition_reveal(id_ds) +
  
  # Escogemos los colores concretos
  scale_fill_manual(values = c("#F4D03F", "#7DCEA0", "#1B4F72","#935116"))

```

###Correlation overview

```{r}

df %>%

  select(-id, -id_sensor, -Fecha_dato) %>%
  
   mutate(Franja_horaria = fct_recode(Franja_horaria,

           "0" = "1min",

           "1" = "Dia 7-19h",
           
           "2" = "Dia_tarde_noche",

           "3" = "Tarde 19-23h",
           
           "4" = "Noche 23-7h")

        ) %>%

  mutate(Dia_medidas = as.numeric(Dia_medidas),

         Estacion = as.numeric(Estacion),

         Franja_horaria = as.numeric(Franja_horaria),

         Nivel_sonoro = as.numeric(Nivel_sonoro)) %>%
        
         ggpairs()


```


### Nivel sonoro medio por dia(Con nivel de concentración)
```{r}
# Seleccionamos el nivel sonoro por día de la semana y el dia
g_dsonoro <- df %>% mutate(Dia_medidas = weekdays(as.Date(Dia_medidas))) %>%  group_by(Dia_medidas) %>% select(Dia_medidas, Nivel_sonoro) %>% unique()

# Hacemos un grafico de violin con ambas variables, de manera que el color 
# dependa del día
g_dsonoro2 <- ggplot(data = g_dsonoro, aes(x = Dia_medidas,y = Nivel_sonoro)) +
  geom_jitter(size = 1, color = 'gray', alpha = 0.5) +
  geom_violin(aes(fill = Dia_medidas), color = 'black', alpha = 0.8) +
geom_boxplot(color = 'black', alpha = 0.9) +
  
# Añadimos una linea horizontal a la altura del Nivel sonoro 
# con el cual el nivel sonoro empieza a afectar a nuestra 
# concentración
  geom_hline(yintercept=70, linetype="dashed", color = "red") +
  
# Añadimos las etiquetas y leyendas
  xlab('Días de la semana') + 
  ylab('Nivel sonoro') +
  ggtitle('Nivel sonoro por días de la semana') + 
  theme_minimal()

#Aplicamos ggplotly para que el gráfico sea interactivo
ggplotly(g_dsonoro2,tooltip = c("x", "y"))
```

### Nivel sonoro por mes (Con limite segun la OMS)
```{r}
meses <-c("enero","febrero","marzo","abril","mayo","junio","julio","agosto",
          "septiembre","octubre","noviembre","diciembre")

# Seleccionamos el nivel sonoro por mes, el mes y el año
g_msonoro <- df  %>% mutate(anyo = year(as.Date(Dia_medidas))) %>% 
  mutate(Dia_medidas = factor(months(as.Date(Dia_medidas))),levels(meses)) %>%  group_by(Dia_medidas) %>%  
  select(Dia_medidas, Nivel_sonoro,anyo)


  
  # Hacemos un grafico de puntos con ambas variables, de manera que el color 
  # dependa del nivel sonoro
  ggplot(g_msonoro) + #geom_col(aes(x= Dia_medidas, y = Media, fill = Media)) + 
  geom_jitter(aes(x= Dia_medidas, y = Nivel_sonoro, col = Nivel_sonoro)) +
  
  # Añadimos una linea horizontal a la altura del Nivel sonoro con el cual 
  # comienza el riesgo de perdida auditiva crónica y otra a la altura del nivel 
  # de ruido recomendado para una vida sana, ambas segun la OMS
  geom_hline(yintercept=85, linetype="dashed", color = "red") +
  geom_hline(yintercept=65, linetype="dashed", color = "blue") +
  
  
  # Añadimos las etiquetas y leyendas
  labs(x = "Meses", y = "Nivel sonoro medio",
       title ="Nivel sonoro por mes") + 
  scale_color_gradient(low="green", high="red") +
  theme(axis.text = element_text(angle = 45))+
  
  facet_grid(.~anyo)



#Aplicamos ggplotly para que el gráfico sea interactivo
#ggplotly(g_msonoro,tooltip = c("x", "y"))
```

Como vemos en el grafico solo se superó el umbral del nivel sonoro cuandos e celebraron las fallas (un año no hubo, el siguiente hubo en septiembre y el siguiente en marzo)

### Nivel sonoro por estación del año
```{r}
#Eliminamos el año del día de medidas y creamos una columna
#que almacena las estaciones del año para cada medida
g_estanyo <- df %>% mutate(Dia_medidas = format(Dia_medidas, format="%m-%d")) %>% mutate(Est_anyo = ifelse(Dia_medidas >= "03-20" & Dia_medidas <= "06-21", "Primavera", ifelse(Dia_medidas >= "06-21" & Dia_medidas <= "09-22", "Verano", ifelse(Dia_medidas >= "09-22" & Dia_medidas <= "12-21", "Otoño", ifelse(Dia_medidas >= "12-21" & Dia_medidas <= "12-31" | Dia_medidas >= "01-01" & Dia_medidas <= "03-20", "Invierno", NA))))) %>% 

#Hacemos un gráfico de puntos y un gráfico de violín
#de manera que el color dependa de la estación del año
ggplot(aes(x = Est_anyo, y = Nivel_sonoro)) + geom_jitter(aes(color = Est_anyo), alpha = 0.05) + geom_violin(aes(fill = Est_anyo), color = "black", alpha = 0.8) + 

  #Añadimos una línea horizontal marcando el umbral a partir del cual el ruido comienza a ser dañino
  geom_hline(yintercept=75, linetype="dashed", color = "red") +
  #Y otra marcando el umbral a partir del cual el sonido se considera ruido según la OMS
  geom_hline(yintercept=65, linetype="dashed", color = "darkblue") + 
  
  #Añadimos etiquetas y título
  labs(x = "Estaciones del año", y = "Nivel sonoro",
       title ="Nivel sonoro por estación del año")

#Aplicamos ggplotly para que el gráfico sea interactivo
ggplotly(g_estanyo,tooltip = c("x", "y"))

#CORREGIR ERROR LEYENDA
```


### Nivel sonoro mascletà
```{r}
#Filtramos para la franja horaria de la mascletà y creamos una nueva columna para determinar qué día hubo mascletà
g_mascleta <- df %>% filter(Franja_horaria == "Dia 7-19h") %>% mutate(hubomascleta = ((Dia_medidas >= as.Date("2021-09-01") & Dia_medidas <= as.Date("2021-09-05")) | Dia_medidas >= as.Date("2022-03-01") & Dia_medidas <= as.Date("2022-03-19"))) %>% 

#Creamos los boxplots, de forma que se divida por estaciones y el color dependa de si hubo o no mascletà
ggplot(aes(x = Estacion, y = Nivel_sonoro, color = hubomascleta)) + geom_boxplot() +

#Ponemos las etiquetas y el título  
labs(x = "Estación", y = "Nivel sonoro", title = "Nivel sonoro con y sin mascletà por estación")

#Utilizamos ggplotly para que el gráfico sea interactivo, con la función layout agrupando por "boxmode" para que no se superpongan los boxplots
ggplotly(g_mascleta,tooltip = c("x", "y", "color")) %>% layout(boxmode = "group")
```
Nota: no hay datos de días de mascletà en la estación 5.
